1. 类型`ifstream`（文件流）和`istringstream`（string流）都继承自`istream`（普通流）。因为一个子类对象可以当作基类对象来使用，所以任何对于`istream`的操作，都可以用在`ifstream`和`istringstream`上。同时为了支持宽字符(`char`到`wchar_t`)，可以在流前加一个`w`变成`wistream`等，对宽字符进行支持。
2. IO对象无法赋值，无法拷贝。作为函数返回值和参数时，都已引用的方式进行传递。因为读写一个IO对象都会影响它的状态，所以不能定义成const的。
3. IO类定义了一组函数和状态，用来检测和操作流的条件状态。其中，有
   1. `strm::badbit`：系统级错误，不可恢复。发生这种错误，这个流就不能用了，会同时置位`failbit`；
   2. `strm::failbit`：可恢复错误，比如期望读取数字而读到字符；
   3. `strm::eofbit`：到达文件结束位置，会与`strm::failbit`一起被置位；
   4. `strm::goodbit`：未发生错误。
    进行条件判断时，如果`badbit`，`failbit`或者`eofbit`任意一个被置位，都会导致判断不通过。所以条件判断实际是判断`!fail()`。也可以通过`rdstate()`，`setstate()`和`clear()`来读取，设置和清空流状态。
4. 每个输出流都有一个缓冲区，用来实现程序的多个输出组合成单一的系统级写操作。导致缓冲刷新的原因有：
   1. 程序正常结束，注意程序异常退出可能导致无法刷新缓冲；
   2. 缓冲区满；
   3. 使用`endl`显示刷新缓冲区；
   4. 通过设置`unitbuf`操作符；
   5. 如果输出流（`cout`）被其他流(`cin`/`cerr`)关联，当其他流进行读写时，被关联的流先刷新缓冲。可以通过`tie`方法关联。
5. 刷新操作符有`endl`，还有`flush`和`ends`。区别在于：
   1. `endl`先输出内容和一个换行符，再执行刷新操作；
   2. `flush`只输出内容，再刷新；
   3. `ends`插入一个空字符。
6. 文件流`fstream`的初始化流程包括创建对象，绑定文件，设置模式等。如果`open`失败，则`failbit`被置位，可以通过条件判断`if (out)`确定是否成功打开文件。如果`fstream`对象离开作用域，则析构函数自动关闭被流打开的文件（`close()`自动调用）。
7. 文件模式有`in`（ifstream默认），`out`（ofstream默认），`trunc`（截断文件，`out`模式默认），`app`（写操作定位在文件末尾），`binary`（二进制），`ate`（打开文件立刻定义到文件末尾）。在`open`时，或者初始化时指定默认，`ofstream out4("file", ofstream::app | ofstream::out);`。