1. 可以在类中，使用`typedef`或者`using`定义别名。注意，类内别名必须先声明再使用，所以通常放在类声明的最前边。
    ```cpp
    class Screen
    {
        public:
            typedef std::string::size_type pos;
            //或者
            using pos = std::string::size_type;
        private:
            // 在pos定义之后才能使用
            pos cursor = 0;
    };
    ```
2. 类中有3种情况下，成员函数为inline的：
   1. 在类内定义的（不需要声明为inline）；
   2. 在类内声明为`inline`的，类外定义时可以不加`inline`；
   3. 类内未声明为`inline`，类外定义时加了`inline`。
3. 可变数据成员，在常量成员函数中也可以修改的成员变量，使用`mutable`，在变量声明时修饰。
4. 类数据成员的初始值。当提供一个类内初始值时，必须使用`=`或者`{}`来表示。
    ```cpp
    class Window_mgr
    {
        private:
            std::vector<Screen>{Screen(24, 80, " ")}
    };
    ```
5. 返回引用的函数是左值，所以类内定义返回类型`Screen&`且在函数中返回`*this`的，都是左值。可以串联执行。函数的返回类型可以定义为`const Screen&`，则返回的左值是常量引用类型，后续只能调用`const`成员函数。
6. 成员函数可以通过`const`来重载，常量对象调用常量版本，非常量对象调用非常用版本。
7. 与函数类似，类也可以只声明，不定义。在被定义之前，它是**不完全类型**，只能用作指针/引用，或者形参类型或返回类型。
8. 友元可以是一个函数，类，或者类的成员函数。声明成员函数为友元时，需要注意类的定义顺序，以及友元成员函数的声明顺序。**友元仅仅代表了访问权限，本身并不是普通意义上的声明。**
9. 在类外定义成员函数时，类名出现之后的部分，都在类的作用域之内，所以参数列表可以直接使用类中的类型定义。但是返回值在类名出现之前，必须要有类访问符。
    ```cpp
    Window_mgr::ScreenIndex Window_mgr::some(ScreenIndex x) {};
    ```
10. 类的编译过程分为两步。先编译类中**所有成员的声明，然后编译函数体**。所以应该把类内的类型声明放在最前边，否则成员声明时可能找不到，或者找成外部的类型声明。成员定义中名字查找顺序位，先函数内部（包括形参），然后类，然后外部。