1. 左值和右值：当一个对象被用作右值的时候，用的对象的值（内容），当被用作左值时，用的是对象的身份（内存地址）。一般来说，需要右值时，可以用左值来代替（使用左值的内容）。但是右值不能代替左值。在`decltype`中，如果表达式结果是左值，则返回的是一个引用。
    ```cpp
    int* p;
    decltype(*p); // *p解引用返回左值，所以类型是int&
    decltype(&p); // 取地址返回右值，类型是int**
    ```
2. c++中，求值顺序与优先级和结合律无关。以`f() + g() * h() + j()`为例，并不知道4个函数的调用顺序，因此如果函数调用有改变共有对象的行为可能会产生莫名其妙的问题。
3. 算数运算符的对象都是右值，返回的也是右值。在表达式求值之前，小整形的运算对象（bool/char）被提升成较大的整形类型（int）。
4. 逻辑非 > 大于小于关系符 > 等于不等于关系符 > 逻辑与/或。逻辑与/或遵循短路求值，第一个表达式的值满足条件才执行第二个表达式。
5. 赋值运算符左侧必须是一个可修改的左值（注意初始化不是赋值`const int i = 1`），运算结果是左侧运算对象，如果右侧与左侧类型不同，则右侧优先转成左侧的类型。赋值运算符的优先级比逻辑和关系运算符都低(`while ((i = get_value()) != 45)`)。
6. 前置自增/自减和后置自增/自减，作用与左值，前置自增/自减将对象返回（左值），后置返回原始值的副本（右值）。
   > 除非必须，尽量不要用后置版本。
7. `*iter++`的含义：`++`优先级更高，先执行`iter++`返回的是`iter`然后执行解引用，最终`iter`也移动到了下一个迭代器（`*(iter + 1)`）。
8. 解引用运算符优先级小于点运算符，所以一定要写成`(*p).size()`。大于自增/自减。
9. 条件运算符的优先级非常低。
    ```cpp
    cout << (grade < 60) ? "fail" : "pass";
    // 等于
    cout << 60; // 返回cout
    cout ? "fail" : "pass";
    ```
