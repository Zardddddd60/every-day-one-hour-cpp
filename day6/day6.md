1. 容器通常含有返回迭代器的成员，比如`begin()`和`end()`。他们返回的是迭代器，可以通过迭代器间接访问对象。`end()`返回的是指向容器**尾元素的下一个位置**。表示已经处理完容器的所有元素。
2. 可以通过`*iter`来访问迭代器指向的元素的**引用**，使用`iter->member`访问迭代器的成员，使用`++iter`或者`--iter`移动迭代器，使用`==`和`!=`判断迭代器是否指向同一个元素。不能对`end()`返回的迭代器进行递增或者解引用，因为它不实际指向一个元素。
3. 迭代器的类型通常是`iterator`或者`const_iterator`(string::iterator vector<int>::const_iterator)。`const_iterator`与常量指针一样，只能读取不能修改。可以使用它来定义常量类型的迭代器。同时，`begin()`和`end()`返回迭代器的类型取决于对象实际是常量。有时候，对于一个非常量对象，我们也只想读不想写，可以通过`cbegin()`和`cend()`，从一个非常量对象返回一个`const_iterator`。
    > 只要是使用了迭代器的循环体，就不要向迭代器所属容器添加元素。
4. 数组声明形如`a[d]`，其中d是维度信息，说明了数组中元素的个数。维度信息在编译时必须是已知的，所以它必须是一个常量表达式`constexpr`定义。默认情况下数组被默认初始化，**内置类型在函数内会被声明成未定义的值**。也可以使用列表初始化的方式初始化，此时维度信息可以被忽略，根据列表初始化中元素的个数决定维度。
5. 字符数组可以使用常量字符串初始化，注意会带一个`\0`在后边。
6. 复杂的数组声明遵循从内向外（从名字开始），从右到左的原则。
    ```cpp
    int* ptrs[10]; // ptrs是一个10维度的数组，内容是int*
    int& ptrs[10]; // 数组的内容不能是引用，这个报错；
    int (*Parray)[10] = &arr; // parray首先是一个指针，指向一个10元素数组，数组类型是int
    int (&rarray)[10] = arr; // rarray是一个引用，引用了一个10元素数组，数组的类型是int
    ```
7. 数组下标类型是`size_t`，一种机器相关的无符号数。同时，也可以使用范围for表里数组中的所有元素。
    ```cpp
    for (auto i : scores) {}
    ```
8. 在很多种情况下，使用数组的名字，编译器会把它转成指向数组首元素的指针。例如，使用一个数组来初始化一个变量，得到的变量类型是指针。但是使用`decltype()`返回的依然是数组，而不是指针。
   ```cpp
   int ia [] = {0, 1, 2};
   auto ia2(ia); // int*
   ```
9. 可以通过`iterator`头文件提供的`begin(arr)`和`end(arr)`，来获得指向首元素的指针，以及尾元素下一个位置的指针。**指向数组的指针，可以执行迭代器运算**。实际上就是移动指针指向的元素。
10. 尽量不要使用c风格字符串，`char ca[] = {'C', '+'};`因为很有可能因为忘记加`\0`导致很多严重的后果。同时，对于字符串的各个操作也十分复杂（使用`cstring`头文件的函数）。string的初始化可以使用带空格符的c风格字符串，string可以通过`c_str()`成员函数生成一个c风格字符串。
11. 可以使用数组类初始化`vector`，需要提供首元素地址和尾元素地址。
    ```cpp
    vector<int> v(begin(int_arr), end(int_arr));
    ```