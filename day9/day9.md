1. 位运算符作用与**整形**类型，如果运算对象是一个小整形（int以下），则它的值自动提升为大整形。
2. 如果一个负数运行位运算，如何处理符号位依赖于机器，是一个未定义的行为。所以建议只对**无符号类型**进行位运算。
3. 位移运算符的优先级低于算数运算符，高于关系运算符，赋值运算符和条件运算符。
4. sizeof即可用于**表达式**，也可用于**类型名字**，返回所占的字节数，返回一个`size_t`。`sizeof`不会真正求一个对象的值。所以作用与一个指针时，即使指针没有初始化，也可以算出指向类型所占的字节数`sizeof (*p)`。求一个类的成员的所占字节时，可以可以`sizeof (Sales_data::revenue)`。
5. 对数组进行`sizeof`，得到整个数组所占空间大小，sizeof不会把数组转成指针处理。sizeof返回一个常量表达式，所以可以用sizeof的返回值，作为数组的维度参数。
    ```cpp
    constexpr size_t sz = sizeof(ia) / sizeof(*ia);
    int arr[sz];
    ```
6. `int ival = 3.541 + 3;`先把3转换成3.0，再把结果转成int。赋值时考虑把右值转成左值类型，而算数运算符两侧会以减少精度损失为原则。整形提升：把小的整形类型提升为较大的整形类型。无符号数与有符号数的类型结合。尽量少的对无符号数和有符号数进行转换，因为依赖于机器环境，还可能带来有符号到无符号的溢出。
7. 数组到指针的装换，在`decltype`，取地址`&`，`sizeof `，`typeid`和用引用初始化数组`auto& i: arr2`时，不会进行转换，其他都会进行转换。指向任意非常量的指针转换成`void*`，指向任意对象的指针转换成`const void*`。把非常量引用和指针转成成常量引用和指针(`const int &j = i;`和`const int* p = &i;`)。
8. 使用`static_cast`，只要不包含底层const，都能转。通常用在把一个较大的运算符类型赋值给较小的类型，表面不在意精度上的损失。还用在把指针存放在`void*`中，恢复到原来的类型`double* dp = static_case<double*>(p);`。
9. `const_case`，改变运算对象的底层const。
    ```cpp
    int main()
    {
        const int i = 0;
        const int& j = i;

        int& k = const_cast<int&>(j); // 必须是<int&>，有效，改变k，j也变了，但i依然是const（不是底层const）
        int& l = const_cast<int&>(i);
        k = 2;
        l = 3; // 不影响i的值

        std::cout << "i: " << i << ", j: " << j << ", k: " << k << " l: " << l << std::endl; // i: 0, j: 2, k: 2

        j = 4; // 报错 j 是 const
    }
    ```
10. `reinterpret_case`就是欺骗编译器，不要用。