1. `string`和`vector`是在连续的内存空间存储的，所以可以使用下标来访问元素。`list`和`forward_list`是通过链表实现的，所以不支持元素随机访问，因为是链表，所以额外空间开销比较大。`array`的对象大小是固定的，不支持插入，删除和修改长度的操作。`deque`双端列表。
2. 通过`value_type`，`reference`，`const_reference`，可以在不了解容器中元素类型的情况下使用它，对于泛型编程很有用。
3. 使用一个容器类型**初始化**另一个容器时，容器类型和元素类型必须都一致。但是当传递迭代参数来拷贝一个范围时，则容器类型可以不一样，元素类型可以转化即可。
4. `array`具有固定大小，在定义时指定大小`array<int, 10> a`。同时，使用`array`的类型时也需要指明大小`array<int,10>size_type i;`。与内置数组不同的是，可以对`array`对象进行拷贝的赋值，只要两个`array`的元素类型和元素数量相同即可。
5. 使用顺序容器的`assign`方法（除`array`），允许从一个不同但相容的类型赋值，或者从一个子序列赋值。用参数指定的元素的**拷贝**替换左边容器的所有元素。
6. 顺序容器的赋值操作，两边的容器类型必须相同，同时元素类型也要相同，而`assign`不需要容器类型相同，元素类型只要相容即可（`const char*`到`string`）。
7. 除`string`外，顺序容器在swap之后，迭代器，引用和指针不会失效，仍指向swap之前指向的元素。对`string`进行`swap`会导致迭代器，指针和引用失效。因为`array`会真正交换元素，所以迭代器，指针和引用的地址不变，但是指向的内容变成了swap之后的内容。
8. 容器的关系运算符使用的是元素的相应运算符。如果元素没有实现相应的运算符，则保存这种元素的容器就不能实现相应的运算。